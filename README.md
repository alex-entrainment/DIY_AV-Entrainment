# DIY Audio-Visual Brainwave Entrainment System (ESP32 + Host Control)

This project aims to create an open-source audio-visual brainwave entrainment system using an **ESP32-C3 microcontroller** controlled via USB Serial by a host computer (PC or Raspberry Pi).

It drives 6 LED channels using the ESP32's native **LEDC PWM peripheral** (assuming external MOSFETs for driving high-power LEDs) and generates/plays synchronized audio entrainment tracks (e.g., binaural, isochronic) on the host computer.

Users can design custom multi-step “sequences” (lighting + audio parameters) with a PyQt-based GUI editor. A converter script then automatically translates these sequences into C++ code, updates the ESP32 firmware, and uploads it. The system is then controlled using a separate Python script that sends commands to the ESP32 and handles synchronized audio playback.

Approximate Device Cost (excluding host PC/Pi): ~$50-75 (depending on LEDs, power supply, enclosure)

---

## Table of Contents

1. [Overview](#overview)
2. [Features](#features)
3. [Visual setup](#visuals)
4. [Audio setup](#audio)
5. [Installation](#installation)
6. [Configuration](#configuration)
7. [Usage](#usage)
8. [GUI Overview](#gui-overview)
9. [Resources](#resources)

---

## Overview

Brainwave entrainment (BWE) involves using pulsing lights or audio tones at specific frequencies to potentially influence brain states. This project provides a flexible platform for experimenting with various stimulation patterns:

* **Visual:** 6 LED channels driven by the ESP32-C3's high-frequency LEDC PWM. Allows adjustable waveforms (sine/square via calculation), duty cycles, frequency ramps, and brightness/intensity control per step.
* **Audio:** Sequences can include audio definitions (up to 3 carriers, binaural/isochronic modes, pink noise, frequency ramps, RFM). Audio waveform files (`.wav`, `.flac`, `.mp3`) can be generated by the GUI editor using the integrated `sound_creator.py` engine. Crucially, audio playback is handled by the **host computer** running the `controller.py` script, synchronized with the start of the LED sequence on the ESP32.

The system is intended for DIY research and experimentation and is **not** a medical device. Build and use at your own discretion and ensure appropriate safety measures, especially regarding light intensity and duration.

## Features

* **PyQt5-based GUI** (`sequence_editor.py`) for creating multi-step visual + audio sequences.
* **ESP32-C3 Native PWM:** Utilizes the microcontroller's efficient LEDC peripheral for precise, high-frequency PWM control of 6 LED channels, eliminating the need for an external PCA9685 board and reducing potential timing jitter.
* **Brightness/Intensity Control:** Per-step start and end intensity values allow for brightness ramps and modulation.
* **Multiple Oscillator Control Modes (in GUI):** Supports Combined, Split, and potentially other modes for defining how the 6 channels behave based on oscillator settings in the JSON.
* **Multi-Step Sequencing:** Design complex sequences with varying parameters over time.
* **Integrated Audio Generation:** The GUI can leverage `sound_creator.py` to generate complex audio tracks (`.wav`, `.flac`, `.mp3`) based on parameters defined within each sequence step (see [Audio Generation Details](#audio)).
* **Random Frequency Modulation (RFM):** Configurable in the GUI for slight variations in visual or audio frequencies. (Note: Visual RFM logic needs ESP32 implementation if desired).
* **Linear Ramps:** Frequencies, duty cycles, and brightness/intensity can transition linearly over the duration of each step. Audio parameters can also ramp using dedicated `_transition` synth functions.
* **JSON File Storage:** Save/load complete sequences (visual + audio parameters) using the GUI editor.
* **Automated C++ Generation & Upload:** A Python script (`json_to_cpp_converter.py`) automatically:
  * Converts `.json` sequence files into C++ functions.
  * Updates the necessary ESP32 firmware files (`sequences.cpp`, `sequences.hpp`, `main.cpp`).
  * Updates the `controller.py` script with the new sequence name.
  * Compiles and uploads the updated firmware to the ESP32 via PlatformIO.
* **Cross-Platform Configuration:** `setup.py` script simplifies configuration (serial ports, paths) for use on both Windows (development) and Raspberry Pi (mobile control).

## Visuals

See the [Visual README](./README_VISUAL.md) for documentation on the visual portion of this project. This contains detailed information on the hardware and its setup.

## Audio

See the [Audio README](./README_Audio.md) for documention on the visual portion of this project. This contains detailed information on the capabilities of the audio generation software created here.  
See the [GUI overview](#gui-overview) below for more details on generating audio.

## Installation

1. **Clone/Download:** Get the project files onto your development PC (Windows) and optionally onto your Raspberry Pi.
2. **Install Python:** Ensure Python 3.8+ is installed on both machines.
3. **Install Python Packages:** Open a terminal or command prompt (use a virtual environment recommended) and install:

    ```bash
    # Core dependencies for GUI, Serial, Audio Generation, Playback
    pip install pyserial numpy soundfile pyaudio PyQt5 configparser scipy

    # scipy is needed by sound_creator for filtering
    # configparser is standard lib >3.2 but listed for clarity
    ```

    > *(Note: `pyaudio` installation might require system dependencies - see below).*
4. **Install PlatformIO:** On your development PC (Windows), install PlatformIO IDE, typically via the VS Code extension. This handles the C++ toolchain (compiler, etc.).
5. **Install External Dependencies:**
    * **Audio Playback (`controller.py`):**
        * **PortAudio:** Required by `pyaudio`. Install system-wide (e.g., `sudo apt-get install portaudio19-dev` on Debian/Pi, or download installers/binaries for Windows/macOS if needed).
        * **libsndfile:** Required by `soundfile`. Install system-wide (e.g., `sudo apt-get install libsndfile1` on Debian/Pi, or download installers/binaries for Windows/macOS).
        * **ffmpeg / ffplay:** Required by `controller.py`'s `AudioPlayer` for MP3 conversion and FLAC playback. Download from ffmpeg.org and ensure `ffmpeg.exe` and `ffplay.exe` are in your system's PATH environment variable on the machine running `controller.py` (Windows and/or Pi).
6. **Hardware Setup:** Connect the ESP32, build/connect your MOSFET driver circuits and LEDs according to the description in [Hardware Components](./README_Visual#hardware-components).
7. **Initial Firmware Upload:** Use PlatformIO (e.g., in VS Code) on your development PC to compile and upload the initial ESP32 firmware project (`main.cpp`, `sequences.cpp`, etc.) to the ESP32-C3 board via USB.

---

## Configuration

Before running the converter or controller scripts, run the setup script once on each machine:

1. Navigate to the directory containing the scripts in your terminal.
2. Run: `python setup.py` (or `python3 setup.py` on Pi).
3. Follow the prompts to enter:
    * The correct **Serial Port** for the ESP32 (e.g., `COM3` on Windows, `/dev/ttyACM0` on Pi).
    * (On Windows Only) Paths to your PlatformIO project, `controller.py`, `platformio.exe`, and the PlatformIO environment name.

This creates/updates the `config.ini` file which is read by the other scripts.

---

## Usage

1. **Create/Save Sequence:** Use `sequence_editor.py` -> `my_sequence.json`. Place it (and optional audio file `my_sequence.wav/flac/mp3`) in the script directory.
2. **Convert/Upload:** Run `python json_to_cpp_converter.py` on Windows. It handles updating C++ files and uploading to ESP32.
3. **Control:** Run `python controller.py` on Windows or Pi.
    * Use `RUN:<sequence_name>` (e.g., `RUN:my_sequence`) to start lights and audio.
    * Use `STOP` to stop the lights on the ESP32.
    * Use `EXIT` to quit the controller script.

---

## GUI Overview

The GUI (`sequence_editor.py`) allows defining sequences step-by-step. Each step has a duration and contains settings for both visual output (oscillators, intensity) and audio output (voices).



* **Steps Panel (Left):** Add, remove, reorder steps, and set duration.
* **Voices Panel (Top Right):** Manage audio voices for the selected step. Add, edit, remove voices. Up to 16 voices can be mixed per step.
* **Voice Details Panel (Bottom Right):** Shows parameters of the selected voice for reference.
* **Voice Editor Dialog (Popup, shown in image):** Opens when adding/editing a voice.
  * Select the **Synth Function** (e.g., `binaural_beat`, `basic_am`).
  * Check **"Is Transition?"** to use the corresponding `_transition` version of the function, enabling parameter ramps (e.g., `startFreq` to `endFreq`).
  * Edit parameters specific to the chosen function. Hints and validation are provided.
  * Use the **Reference Panel** within the dialog to compare with another voice selected in the main window.
* **Global Settings (Top Bar):** Set sample rate, crossfade time between steps, and default output filename.
* **Generate Audio (Top Bar):** Click to export the complete audio track for the entire sequence. The file format is determined by the extension you choose (e.g., `.wav`, `.flac`, `.mp3`).

---

## Resources

* [Creating your own Light Sequences](https://support.pandorastar.co.uk/wp-content/uploads/sites/6/2021/01/Creating-your-own-sequences-on-PandoraStar-1.pdf)
* [List of proprietary programs from PandoraStar](https://support.pandorastar.co.uk/wp-content/uploads/sites/6/2021/01/PS-Program-List-2020.pdf)
* [Gnaural binaural / isochronic tone creation software](https://gnaural.sourceforge.net/)
* [Research on photic entrainment / driving](...)
