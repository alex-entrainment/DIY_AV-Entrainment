# Web UI for the Realtime Backend

This directory provides a minimal browser interface for the Rust audio engine
when compiled to WebAssembly. It is meant for quick experimentation directly
from a web page.

## Building the WebAssembly Package

1. Install [`wasm-pack`](https://rustwasm.github.io/wasm-pack/installer/).
2. Build the backend with the `web` feature enabled:
   ```bash
   cd ../realtime_backend
   wasm-pack build --target web --release --no-default-features --features web
   ```
3. Run `npm run sync-wasm` (or any of the dev/build scripts) to copy the
   generated `pkg` folder into `src/pkg` so Vite can bundle
   `realtime_backend.js` and `realtime_backend_bg.wasm`.
   When importing the module in JavaScript, append `?import` to the path
   so Vite treats it as an ES module:

   ```javascript
   import init from '/src/pkg/realtime_backend.js?import';
   ```

## Running the Demo

Install the npm dependencies and start the development server. **Vite 5 requires Node.js 20 or newer**, so ensure you have an up-to-date Node.js installation:

```bash
npm install
npm run dev
```

`npm run dev` will automatically copy the latest WASM build from
`../realtime_backend/pkg` into the `src/pkg` directory before starting Vite.

Vite will serve the application at the printed URL. You can either paste a track
JSON object into the text box or use the **Upload** field to load a `.json`
file. Use the **Start** button to begin playback and **Stop** to halt the engine.
Additional controls allow pausing/resuming playback, seeking to a specific
position, updating the track JSON while running, and toggling GPU mixing. The
current step index and elapsed sample count are displayed below the controls.

The JavaScript code now creates the `AudioContext` using the `sample_rate`
specified in the track JSON (falling back to `44100` if not provided). This
prevents pitch or tempo shifts when the track was rendered for a different
sample rate than your browser's default.

### Low Latency AudioWorklet

The demo uses an `AudioWorklet` and a shared ring buffer to stream audio samples
generated by the WASM module. The main thread fills the buffer using
`process_block` while the worklet reads from it inside the audio callback. This
approach avoids large memory allocations and provides lower latency than the old
`ScriptProcessor` implementation.
